

#include "comm.h"
#include "KnockMotor.h"
#include "KneadMotor.h"
#include "WalkMotor.h"
#include "MotorCtrl.h"
#include "Input.h"
#include "Timer.h"
extern __no_init _Bool bCheckWalkBottom;
extern __no_init unsigned short nWalk_TOP_POSITION ;//1号机芯行走坐标最大值

unsigned char nBackMainRunMode,nBackSubRunMode;
unsigned char nCurKneadKnockSpeed,nCurKnockRunStopCounter,nCurActionStepCounter;
unsigned char bKnockMotorInProcess,bKneadMotorInProcess,bWalkMotorInProcess;
unsigned char nCurKneadMotorCycles;
unsigned char bUpdateLocate;
unsigned short nShoulderPosition;

_Bool bHasKneadWidthMinPulse,bHasKneadWidthMedPulse,bHasKneadWidthMaxPulse;

//捶击电机控制
void KnockMotorControl(unsigned char nKnockMotorState,unsigned char nKnockingMotorRunTime,unsigned char nKnockingMotorStopTime)
{
    static _Bool bKnockMotorPowerFlag;
    unsigned char step;
		//syx 20160424
    //敲打电机音乐互动（高频）
    //if((nBackMainRunMode == BACK_MAIN_MODE_MANUAL) &&
    //    (nBackSubRunMode == BACK_SUB_MODE_MUSIC) &&
		//		(nKnockMotorState == KNOCK_RUN_MUSIC))
    //{
    //    nMusicKnockPWM = AD_KNOCK_PWM(nAvrADResult0) ;
    //    KnockMotor_Set_Pwm_Data(nMusicKnockPWM);
    //    bKnockMotorInProcess = FALSE ;
    //}
    //else
    {
        if(bKnockMotorInProcess == TRUE)
        {
            switch(nKnockMotorState)
            {
            default:
                bKnockMotorInProcess = FALSE ;
                while(1)
                {
                    //WDOG_Feed();
                }
                break;
            case KNOCK_STOP:
                bKnockMotorPowerFlag = FALSE ;
                if(nCurActionStepCounter >= nKnockingMotorRunTime)
                {
                    bKnockMotorInProcess = FALSE ;
                }
                break ;
            case KNOCK_RUN_WIDTH://定位宽中窄完成后进行
                if(bKneadMotorInProcess == TRUE)
                {
                    bKnockMotorPowerFlag = FALSE ;
                    nCurActionStepCounter = 0 ;
                }
                else
                {
                    bKnockMotorPowerFlag = TRUE ;
                    if(nCurActionStepCounter >= nKnockingMotorRunTime)
                    {
                        bKnockMotorInProcess = FALSE ;
                    }
                }
                break ;
            case KNOCK_RUN://敲击电机直接运行
                bKnockMotorPowerFlag = TRUE ;
                if(nCurActionStepCounter >= nKnockingMotorRunTime)
                {
                    bKnockMotorInProcess = FALSE ;
                }
                break ;
            case KNOCK_RUN_STOP:  //叩击
                if(bKneadMotorInProcess == TRUE)
                {
                    bKnockMotorPowerFlag = FALSE ;
                    nCurKnockRunStopCounter = 0 ;//叩击动作记数器
                }
                else
                {
                    if(nCurKnockRunStopCounter < nKnockingMotorRunTime)//nCurKnockRunStopCounter:单位:2ms; nKnockingMotorRunTime:单位:100ms;
                    {
                        bKnockMotorPowerFlag = TRUE ;
                    }
                    if((nCurKnockRunStopCounter >= nKnockingMotorRunTime) && (nCurKnockRunStopCounter < (nKnockingMotorRunTime + nKnockingMotorStopTime)))
                    {
                        bKnockMotorPowerFlag = FALSE ;
                        //行走电机完成动作时，该动作也结束
                        
                        if(bWalkMotorInProcess == FALSE)
                        {
                            bKnockMotorInProcess = FALSE ;
                        }
                        
                    }
                    if(nCurKnockRunStopCounter >= (nKnockingMotorRunTime + nKnockingMotorStopTime))
                    {
                        nCurKnockRunStopCounter = 0 ;
                    }
                }
                break ;
            case KNOCK_RUN_MUSIC:
                break ;
                
            case KNOCK_RUN_PINCH_SHOULDER     :
              
                        //1、捏肩时先判断是在0点，不在0点，跑到0点后进行一次捏肩动作
         //  if(nCurKneadMotorCycles > nKneadMotorCycles)
                  step = nCurActionStepCounter % 4; 
                  switch(step)
                  {
                  case 0: 
                      /**************判断是否到达最窄处*************************/
                      
                      if(Input_GetKnock_Originl_Point()==0)
                      {
                         // bHasKneadWidthMinPulse = FALSE ;
                        //  nCurKneadWidth = KNEAD_WIDTH_MIN ;
                          if(Input_GetKnead_Originl_Point()==0)
                          {
                            nCurActionStepCounter++ ;       //到达窄位置加1
                          
                            Timer_Counter_Clear(C_TIME_Pinch_shoulder_Knock); 
                          }
                         // nFinalKneadMotorState = STATE_IDLE ;
                          bKnockMotorPowerFlag = FALSE ;
                      }
                      else           //
                      {
                         //  nCurKneadWidth = KNEAD_WIDTH_UNKNOWN_2 ;
                          bKnockMotorPowerFlag = TRUE ;
                         // nFinalKneadMotorState = STATE_RUN_CLOCK ; //还未到达最窄处，继续逆时针转动
       
                      }
                      /*********************************************/
                      //1、先逆时针转动到窄的位置
                      //2\停在最窄处,准备从最窄到最宽，进行顺时针运动
                      //3\从窄到宽顺时针转动,，同时判断是否到宽的位置
                      //4\到达宽的位置停止100ms后，再开始逆时针转动 
                      break; 
                  case 1:  //停在最窄处
                      /**************判断刹车时间************************/
                      if(Timer_Counter(C_TIME_Pinch_shoulder_Knock,2)) 
                      {
                          nCurActionStepCounter++ ;       //加1
                         // nFinalKneadMotorState = STATE_RUN_CLOCK ; //从最窄到最宽，进行顺时针运动
                           bKnockMotorPowerFlag = TRUE ;
                      }
                      else
                      {
                          bKnockMotorPowerFlag = FALSE ;
                      }
                      /*********************************************/
                      break;
                  case 2: 
                      /**************判断是否到达最宽处*************************/
                    //  if(bHasKneadWidthMaxPulse == TRUE)
                      if(Input_GetKnock_Originl_Point()==0)//是否回到原点位置
                      {

                          nCurActionStepCounter++ ;       //到达宽位置加1
                          Timer_Counter_Clear(C_TIME_Pinch_shoulder_Knock); 
                   
                            bKnockMotorPowerFlag = FALSE ;
                      }
                      else
                      {
                            bKnockMotorPowerFlag = TRUE ;

                      }
                      /*********************************************/
                      break;  
                  case 3: 
                      /**************判断刹车时间************************/
                      if(Timer_Counter(C_TIME_Pinch_shoulder_Knock,2)) 
                      {
                          nCurActionStepCounter++ ;       //加1
                          
                          if(nCurActionStepCounter > nKnockingMotorRunTime)
                          {
                              bKnockMotorPowerFlag = FALSE ;
                              //nFinalKneadMotorState = STATE_IDLE ;
                              
                             // if(bWalkMotorInProcess == FALSE)
                              {
                                 // bKneadMotorInProcess = FALSE ;
                                    bKnockMotorPowerFlag = FALSE ;
                              }
                          }
                          else
                          {
                               bKnockMotorPowerFlag = TRUE ;
                             // nFinalKneadMotorState = STATE_RUN_CLOCK ; //从最窄到最宽，进行顺时针运动 
                          }
                      }
                      else
                      {  
                            bKnockMotorPowerFlag = FALSE ;
                        //  nFinalKneadMotorState = STATE_IDLE ;
                      }
                      /*********************************************/

                   
                   
                 }
              
              
              
              
              
              break;
                
            }
        }
        if(bKnockMotorPowerFlag == TRUE)
        {
            switch(nCurKneadKnockSpeed)
            {
            case 1:
                KnockMotor_Set_Pwm_Data(KNOCK_SPEED1_PWM);
                break ;
            case 2:
                KnockMotor_Set_Pwm_Data(KNOCK_SPEED2_PWM);
                break ;
            case 3:
                KnockMotor_Set_Pwm_Data(KNOCK_SPEED3_PWM);
                break ;
            case 4:
                KnockMotor_Set_Pwm_Data(KNOCK_SPEED4_PWM);
                break ;
            case 5:
                KnockMotor_Set_Pwm_Data(KNOCK_SPEED5_PWM);
                break ;
            case 6:
                KnockMotor_Set_Pwm_Data(KNOCK_SPEED6_PWM);
                break ;
            default:
                KnockMotor_Set_Pwm_Data(KNOCK_SPEED1_PWM);
                break ;
            }
            //KnockMotor_ClockRun();
        }
        else
        {  
            KnockMotor_Set_Pwm_Data(KNOCK_SPEED0_PWM);
            KnockMotor_Break();
        }
    }
}

void main_GetKneadPosition(void)
{        
#ifdef addr_1  //有宽中窄
  
  
    static unsigned char nLastKneadPosition = KNEAD_WIDTH_UNKNOWN;
    unsigned char nNowKneadPosition = Input_GetKneadPosition();
    if(nNowKneadPosition != nLastKneadPosition) 
    {
        //nWidthOverTime = 0; //syx 20160424
        if(nNowKneadPosition == KNEAD_WIDTH_MIN)
        {
            bHasKneadWidthMinPulse = TRUE ;
            bHasKneadWidthMedPulse = FALSE ;
            bHasKneadWidthMaxPulse = FALSE ;
            //bDisplayKneadTrackMin = TRUE ;  //syx 20160424
            //bDisplayKneadTrackMed = FALSE ;
            //bDisplayKneadTrackMax = FALSE ;
            //bDisplayKneadWidthMin = TRUE ;
            //bDisplayKneadWidthMed = FALSE ;
            //bDisplayKneadWidthMax = FALSE ;
            nLastKneadPosition = KNEAD_WIDTH_MIN ;
        }
        if(nNowKneadPosition == KNEAD_WIDTH_MED)
        {
            bHasKneadWidthMinPulse = FALSE ;
            bHasKneadWidthMedPulse = TRUE ;
            bHasKneadWidthMaxPulse = FALSE ;
            //bDisplayKneadTrackMin = FALSE ;
            //bDisplayKneadTrackMed = TRUE ;
            //bDisplayKneadTrackMax = FALSE ;
            //bDisplayKneadWidthMin = FALSE ;
            //bDisplayKneadWidthMed = TRUE ;
            //bDisplayKneadWidthMax = FALSE ;
            //nLastKneadPosition = KNEAD_WIDTH_MED ;
        }
        if(nNowKneadPosition == KNEAD_WIDTH_MAX)
        {
            bHasKneadWidthMinPulse = FALSE ;
            bHasKneadWidthMedPulse = FALSE ;
            bHasKneadWidthMaxPulse = TRUE ;
            //bDisplayKneadTrackMin = FALSE ;
            //bDisplayKneadTrackMed = FALSE ;
            //bDisplayKneadTrackMax = TRUE ;
            //bDisplayKneadWidthMin = FALSE ;
            //bDisplayKneadWidthMed = FALSE ;
            //bDisplayKneadWidthMax = TRUE ;
            nLastKneadPosition = KNEAD_WIDTH_MAX ;
        }
    }
#else
    
    if(Input_GetKneadLocation()==KNEAD_WIDTH_MIN_PULSE)
    {
            bHasKneadWidthMinPulse = TRUE ;
            bHasKneadWidthMedPulse = FALSE ;
            bHasKneadWidthMaxPulse = FALSE ;
    }
    if(Input_GetKneadLocation()==KNEAD_WIDTH_MED_PULSE)
    {
            bHasKneadWidthMinPulse = FALSE ;
            bHasKneadWidthMedPulse = TRUE ;
            bHasKneadWidthMaxPulse = FALSE ;
    } 
    if(Input_GetKneadLocation()==KNEAD_WIDTH_MAX_PULSE)
    {
            bHasKneadWidthMinPulse = FALSE ;
            bHasKneadWidthMedPulse = FALSE ;
            bHasKneadWidthMaxPulse = TRUE ;
    }
#endif
    
}

void KneadMotorControl(unsigned char nKneadMotorState,unsigned char nKneadMotorCycles)
{
    unsigned int speed;
    unsigned int step;
		static unsigned char nFinalKneadMotorState = STATE_IDLE; //syx 20160424
		static unsigned char nCurKneadWidth = KNEAD_WIDTH_UNKNOWN; //syx 20160424
                
                
                
    if(bKneadMotorInProcess == TRUE)
    {
        switch(nKneadMotorState)
        {
        default:
        case KNEAD_STOP:
            nFinalKneadMotorState = STATE_IDLE ;
            bKneadMotorInProcess = FALSE ;
            break ;
        case KNEAD_STOP_AT_MIN:
            if(nCurKneadWidth == KNEAD_WIDTH_MIN)
            {
                nFinalKneadMotorState = STATE_IDLE ;
                bKneadMotorInProcess = FALSE ;
            }
            else
            {
                if(bHasKneadWidthMinPulse == TRUE)
                {
                    bHasKneadWidthMinPulse = FALSE ;
                    if(Input_GetKneadMin() == 0)
                    {
                        nCurKneadWidth = KNEAD_WIDTH_MIN ;
                        nFinalKneadMotorState = STATE_IDLE ;
                        bKneadMotorInProcess = FALSE ;
                    }
                }
                else
                {
                    nCurKneadWidth = KNEAD_WIDTH_UNKNOWN ;
                    nFinalKneadMotorState = STATE_RUN_CLOCK ;
                }
            }
            break ;
        case KNEAD_STOP_AT_MED:
            if(nCurKneadWidth == KNEAD_WIDTH_MED)
            {
                nFinalKneadMotorState = STATE_IDLE ;
                bKneadMotorInProcess = FALSE ;
            }
            else
            {
                if(bHasKneadWidthMedPulse == TRUE)
                {
                    bHasKneadWidthMedPulse = FALSE ;
                    if(Input_GetKneadMid() == 0)
                    {
                        nCurKneadWidth = KNEAD_WIDTH_MED ;
                        nFinalKneadMotorState = STATE_IDLE ;
                        bKneadMotorInProcess = FALSE ;
                    }
                }
                else
                {
                    nCurKneadWidth = KNEAD_WIDTH_UNKNOWN ;
                    nFinalKneadMotorState = STATE_RUN_CLOCK ;
                }
            }
            break ;
        case KNEAD_STOP_AT_MAX:
            if(nCurKneadWidth == KNEAD_WIDTH_MAX)
            {
                nFinalKneadMotorState = STATE_IDLE ;
                bKneadMotorInProcess = FALSE ;
            }
            else
            {
                if(bHasKneadWidthMaxPulse == TRUE)
                {
                    bHasKneadWidthMaxPulse = FALSE ;
                    if(Input_GetKneadMax() == 0)
                    {
                        nCurKneadWidth = KNEAD_WIDTH_MAX ;
                        nFinalKneadMotorState = STATE_IDLE ;
                        bKneadMotorInProcess = FALSE ;
                    }
                }
                else
                {
                    nCurKneadWidth = KNEAD_WIDTH_UNKNOWN ;
                    nFinalKneadMotorState = STATE_RUN_CLOCK ;
                }
            }
            break ;
        case KNEAD_RUN:
            nCurKneadWidth = KNEAD_WIDTH_UNKNOWN ;
            nFinalKneadMotorState = STATE_RUN_CLOCK ;
            bKneadMotorInProcess = FALSE ;
            break ;
        case KNEAD_RUN_STOP:
        case KNEAD_RUN_STOP_AT_MIN:
            if(bHasKneadWidthMinPulse == TRUE)
            {
                bHasKneadWidthMinPulse = FALSE ;
                nCurKneadMotorCycles++ ;
                if(nCurKneadMotorCycles > nKneadMotorCycles)
                {
                    if(Input_GetKneadMin() == 0)  
                    {
                        nCurKneadWidth = KNEAD_WIDTH_MIN ;
                        nFinalKneadMotorState = STATE_IDLE ;
                        bKneadMotorInProcess = FALSE ;
                    }
                }
            }
            else
            {
                nCurKneadWidth = KNEAD_WIDTH_UNKNOWN ;
                nFinalKneadMotorState = STATE_RUN_CLOCK ;
            }
            break ;
        case KNEAD_RUN_STOP_AT_MED:
            if(bHasKneadWidthMedPulse == TRUE)
            {
                bHasKneadWidthMedPulse = FALSE ;
                nCurKneadMotorCycles++ ;
                if(nCurKneadMotorCycles > nKneadMotorCycles)
                {
                    if(Input_GetKneadMid() == 0)
                    {
                        nCurKneadWidth = KNEAD_WIDTH_MED ;
                        nFinalKneadMotorState = STATE_IDLE ;
                        bKneadMotorInProcess = FALSE ;
                    }
                }
            }
            else
            {
                nCurKneadWidth = KNEAD_WIDTH_UNKNOWN ;
                nFinalKneadMotorState = STATE_RUN_CLOCK ;
            }
            break ;
        case KNEAD_RUN_STOP_AT_MAX:
            if(bHasKneadWidthMaxPulse == TRUE)
            {
                bHasKneadWidthMaxPulse = FALSE ;
                nCurKneadMotorCycles++ ;
                if(nCurKneadMotorCycles > nKneadMotorCycles)
                {
                    if(Input_GetKneadMax() == 0)
                    {
                        nCurKneadWidth = KNEAD_WIDTH_MAX ;
                        nFinalKneadMotorState = STATE_IDLE ;
                        bKneadMotorInProcess = FALSE ;
                    }
                }
            }
            else
            {
                nCurKneadWidth = KNEAD_WIDTH_UNKNOWN ;
                nFinalKneadMotorState = STATE_RUN_CLOCK ;
            }
            break ;
            //顺时针：窄-中-宽-半圈空闲-窄     
            //逆时针：宽-中-窄-半圈空闲-宽          
            /*
            搓背程序依据  nCurKneadMotorCycles的值控制揉捏电机    
            */
        case KNEAD_RUN_RUBBING:
            step = nCurKneadMotorCycles % 4;
            switch(step)
            {
            case 0: 
                /**************判断是否到达最窄处*************************/
                if(bHasKneadWidthMinPulse == TRUE)
                {
                    bHasKneadWidthMinPulse = FALSE ;
                    nCurKneadWidth = KNEAD_WIDTH_MIN ;
                    nCurKneadMotorCycles++ ;       //到达窄位置加1
                    Timer_Counter_Clear(C_TIME_RUBBING); 
                    nFinalKneadMotorState = STATE_IDLE ;
                }
                else           //
                {
                    nCurKneadWidth = KNEAD_WIDTH_UNKNOWN ;
                    nFinalKneadMotorState = STATE_RUN_UNCLOCK ; //还未到达最窄处，继续逆时针转动
                }
                /*********************************************/
                //1、先逆时针转动到窄的位置
                //2\停在最窄处,准备从最窄到最宽，进行顺时针运动
                //3\从窄到宽顺时针转动,，同时判断是否到宽的位置
                //4\到达宽的位置停止100ms后，再开始逆时针转动 
                break; 
            case 1:  //停在最窄处
                /**************判断刹车时间************************/
                if(Timer_Counter(C_TIME_RUBBING,1)) 
                {
                    nCurKneadMotorCycles++ ;       //加1
                    nFinalKneadMotorState = STATE_RUN_CLOCK ; //从最窄到最宽，进行顺时针运动
                }
                else
                {
                    nFinalKneadMotorState = STATE_IDLE ;
                }
                /*********************************************/
                break;
            case 2: 
                /**************判断是否到达最宽处*************************/
                if(bHasKneadWidthMaxPulse == TRUE)
                {
                    bHasKneadWidthMaxPulse = FALSE ;
                    nCurKneadWidth = KNEAD_WIDTH_MAX ;
                    nCurKneadMotorCycles++ ;       //到达宽位置加1
                    Timer_Counter_Clear(C_TIME_RUBBING); 
                    nFinalKneadMotorState = STATE_IDLE ;
                }
                else
                {
                    nCurKneadWidth = KNEAD_WIDTH_UNKNOWN ;
                    nFinalKneadMotorState = STATE_RUN_CLOCK ; //从窄到宽顺时针转动
                }
                /*********************************************/
                break;  
            case 3: 
                /**************判断刹车时间************************/
                if(Timer_Counter(C_TIME_RUBBING,1)) 
                {
                    nCurKneadMotorCycles++ ;       //加1
                    
                    if(nCurKneadMotorCycles > nKneadMotorCycles)
                    {
                        nFinalKneadMotorState = STATE_IDLE ;
                        
                        if(bWalkMotorInProcess == FALSE)
                        {
                            bKneadMotorInProcess = FALSE ;
                        }
                    }
                    else
                    {
                        nFinalKneadMotorState = STATE_RUN_UNCLOCK ; //从最窄到最宽，进行顺时针运动 
                    }
                }
                else
                {
                    nFinalKneadMotorState = STATE_IDLE ;
                }
                /*********************************************/
                break;  
            }
            
            break;
        }
    }
    //确定揉捏马达的速度
    if((nKneadMotorState == KNEAD_STOP_AT_MIN) ||
       (nKneadMotorState == KNEAD_STOP_AT_MED) ||
           (nKneadMotorState == KNEAD_STOP_AT_MAX) ||
               (nKneadMotorState == KNEAD_RUN_STOP) )
    {
        speed =  KNEAD_SPEED2_PWM;
    }
    else
    {
        switch(nCurKneadKnockSpeed)
        {
        default:  
        case 1:speed = KNEAD_SPEED1_PWM;  break ;
        case 2:speed = KNEAD_SPEED2_PWM;  break ;
        case 3:speed = KNEAD_SPEED3_PWM;  break ;
        case 4:speed = KNEAD_SPEED4_PWM;  break ;
        case 5:speed = KNEAD_SPEED5_PWM;  break ;
        case 6:speed = KNEAD_SPEED6_PWM;  break ;
        }
    }
    if(nFinalKneadMotorState == STATE_RUN_CLOCK)
    {
        KneadMotor_Control(STATE_KNEAD_CLOCK_RUN,speed);
    }
    if(nFinalKneadMotorState == STATE_RUN_UNCLOCK)
    {
        KneadMotor_Control(STATE_KNEAD_UNCLOCK_RUN,speed);
    }
    if(nFinalKneadMotorState == STATE_IDLE)
    {
        KneadMotor_Control(STATE_KNEAD_IDLE,speed);
    }
}
//-----------------------------------------------------------------

void KneadMotorControl_2(unsigned char nKneadMotorState,unsigned char nKneadMotorCycles)
{
#ifndef   addr_1  //有宽中窄
  
  
    unsigned int speed;
    unsigned int step;
    
    static unsigned char nFinalKneadMotorState = STATE_IDLE; //syx 20160424
    static unsigned char nCurKneadWidth = KNEAD_WIDTH_UNKNOWN_2; //syx 20160424
    if(bKneadMotorInProcess == TRUE)
    {
        switch(nKneadMotorState)
        {
        default:
        case KNEAD_STOP_AT_TARGET_POSTION_2:
          
           if(Input_GetKneadLocation()==nKneadMotorCycles)
           {
                 nFinalKneadMotorState = STATE_IDLE ;
                 bKneadMotorInProcess = FALSE ;
             
           }
           else
           {
              nCurKneadWidth = KNEAD_WIDTH_UNKNOWN_2 ;
              nFinalKneadMotorState = STATE_RUN_CLOCK ;
           }
          break;
        case  KNEAD_STOP_AT_PINCH_SHOULDER ://捏肩
          //1、捏肩时先判断是在0点，不在0点，跑到0点后进行一次捏肩动作
         //  if(nCurKneadMotorCycles > nKneadMotorCycles)
            step = nCurKneadMotorCycles % 4; 
            switch(step)
            {
            case 0: 
                /**************判断是否到达最窄处*************************/
                if(Input_GetKnead_Originl_Point()==0)//if(bHasKneadWidthMinPulse == TRUE)
                {
                   // bHasKneadWidthMinPulse = FALSE ;
                  //  nCurKneadWidth = KNEAD_WIDTH_MIN ;
                    if(Input_GetKnock_Originl_Point()==0)
                    {
                      nCurKneadMotorCycles++ ;       //到达窄位置加1
                    
                      Timer_Counter_Clear(C_TIME_Pinch_shoulder_Knead  ); 
                    }
                    nFinalKneadMotorState = STATE_IDLE ;
                }
                else           //
                {
                     nCurKneadWidth = KNEAD_WIDTH_UNKNOWN_2 ;
                    nFinalKneadMotorState = STATE_RUN_CLOCK ; //还未到达最窄处，继续逆时针转动
 
                }
                /*********************************************/
                //1、先逆时针转动到窄的位置
                //2\停在最窄处,准备从最窄到最宽，进行顺时针运动
                //3\从窄到宽顺时针转动,，同时判断是否到宽的位置
                //4\到达宽的位置停止100ms后，再开始逆时针转动 
                break; 
            case 1:  //停在最窄处
                /**************判断刹车时间************************/
                if(Timer_Counter(C_TIME_Pinch_shoulder_Knead  ,2)) 
                {
                    nCurKneadMotorCycles++ ;       //加1
                    nFinalKneadMotorState = STATE_RUN_CLOCK ; //从最窄到最宽，进行顺时针运动
                }
                else
                {
                    nFinalKneadMotorState = STATE_IDLE ;
                }
                /*********************************************/
                break;
            case 2: 
                /**************判断是否到达最宽处*************************/
              //  if(bHasKneadWidthMaxPulse == TRUE)
                if(Input_GetKnead_Originl_Point()==0)//是否回到原点位置
                {
                   // bHasKneadWidthMaxPulse = FALSE ;
                  //  nCurKneadWidth = KNEAD_WIDTH_MAX ;
                //    nCurKneadWidth = KNEAD_WIDTH_UNKNOWN_2 ;
                    nCurKneadMotorCycles++ ;       //到达宽位置加1
                    Timer_Counter_Clear(C_TIME_Pinch_shoulder_Knead  ); 
                    nFinalKneadMotorState = STATE_IDLE ;
                }
                else
                {
                    nCurKneadWidth = KNEAD_WIDTH_UNKNOWN_2 ;
                    nFinalKneadMotorState = STATE_RUN_CLOCK ; //从窄到宽顺时针转动
                }
                /*********************************************/
                break;  
            case 3: 
                /**************判断刹车时间************************/
                if(Timer_Counter(C_TIME_Pinch_shoulder_Knead  ,2)) 
                {
                    nCurKneadMotorCycles++ ;       //加1
                    
                    if(nCurKneadMotorCycles > nKneadMotorCycles)
                    {
                        nFinalKneadMotorState = STATE_IDLE ;
                        
                        if(bWalkMotorInProcess == FALSE)
                        {
                            bKneadMotorInProcess = FALSE ;
                        }
                    }
                    else
                    {
                        nFinalKneadMotorState = STATE_RUN_CLOCK ; //从最窄到最宽，进行顺时针运动 
                    }
                }
                else
                {
                    nFinalKneadMotorState = STATE_IDLE ;
                }
                /*********************************************/

             
             
           }
          

          
          break;
          
          
          
        case KNEAD_STOP_2:
            nFinalKneadMotorState = STATE_IDLE ;
            bKneadMotorInProcess = FALSE ;
            break ;
        case KNEAD_STOP_AT_MIN_2:
            if(nCurKneadWidth == KNEAD_WIDTH_MIN_2)
            {
                nFinalKneadMotorState = STATE_IDLE ;
                bKneadMotorInProcess = FALSE ;
            }
            else
            {
                if(bHasKneadWidthMinPulse == TRUE)
                {
                    bHasKneadWidthMinPulse = FALSE ;
                    //if(Input_GetKneadMin() == 0)
                   // {
                        nCurKneadWidth = KNEAD_WIDTH_MIN_2 ;
                        nFinalKneadMotorState = STATE_IDLE ;
                        bKneadMotorInProcess = FALSE ;
                    //}
                }
                else
                {
                    nCurKneadWidth = KNEAD_WIDTH_UNKNOWN_2 ;
                    nFinalKneadMotorState = STATE_RUN_CLOCK ;
                }
            }
            break ;
        case KNEAD_STOP_AT_MED_2:
            if(nCurKneadWidth == KNEAD_WIDTH_MED_2)
            {
                nFinalKneadMotorState = STATE_IDLE ;
                bKneadMotorInProcess = FALSE ;
            }
            else
            {
                if(bHasKneadWidthMedPulse == TRUE)
                {
                    bHasKneadWidthMedPulse = FALSE ;
                 //   if(Input_GetKneadMid() == 0)
                   // {
                        nCurKneadWidth = KNEAD_WIDTH_MED_2 ;
                        nFinalKneadMotorState = STATE_IDLE ;
                        bKneadMotorInProcess = FALSE ;
                    //}
                }
                else
                {
                    nCurKneadWidth = KNEAD_WIDTH_UNKNOWN_2 ;
                    nFinalKneadMotorState = STATE_RUN_CLOCK ;
                }
            }
            break ;
        case KNEAD_STOP_AT_MAX_2:
            if(nCurKneadWidth == KNEAD_WIDTH_MAX_2)
            {
                nFinalKneadMotorState = STATE_IDLE ;
                bKneadMotorInProcess = FALSE ;
            }
            else
            {
                if(bHasKneadWidthMaxPulse == TRUE)
                {
                    bHasKneadWidthMaxPulse = FALSE ;
                 //   if(Input_GetKneadMax() == 0)
                 //   {
                        nCurKneadWidth = KNEAD_WIDTH_MAX_2 ;
                        nFinalKneadMotorState = STATE_IDLE ;
                        bKneadMotorInProcess = FALSE ;
                  //  }
                }
                else
                {
                    nCurKneadWidth = KNEAD_WIDTH_UNKNOWN_2 ;
                    nFinalKneadMotorState = STATE_RUN_CLOCK ;
                }
            }
            break ;
            
            
            
        case KNEAD_RUN_2:
            nCurKneadWidth = KNEAD_WIDTH_UNKNOWN_2 ;
            nFinalKneadMotorState = STATE_RUN_CLOCK ;
            bKneadMotorInProcess = FALSE ;
            break ;
        case KNEAD_RUN_STOP_2:
        case KNEAD_RUN_STOP_AT_MIN_2:
            if(bHasKneadWidthMinPulse == TRUE)
            {
                bHasKneadWidthMinPulse = FALSE ;
                nCurKneadMotorCycles++ ;
                if(nCurKneadMotorCycles > nKneadMotorCycles)
                {
                    //if(Input_GetKneadMin() == 0)  
                    {
                        nCurKneadWidth = KNEAD_WIDTH_MIN_2 ;
                        nFinalKneadMotorState = STATE_IDLE ;
                        bKneadMotorInProcess = FALSE ;
                    }
                }
            }
            else
            {
                nCurKneadWidth = KNEAD_WIDTH_UNKNOWN_2 ;
                nFinalKneadMotorState = STATE_RUN_CLOCK ;
            }
            break ;
        case KNEAD_RUN_STOP_AT_MED_2:
            if(bHasKneadWidthMedPulse == TRUE)
            {
                bHasKneadWidthMedPulse = FALSE ;
                nCurKneadMotorCycles++ ;
                if(nCurKneadMotorCycles > nKneadMotorCycles)
                {
                   // if(Input_GetKneadMid() == 0)
                    {
                        nCurKneadWidth = KNEAD_WIDTH_MED_2 ;
                        nFinalKneadMotorState = STATE_IDLE ;
                        bKneadMotorInProcess = FALSE ;
                    }
                }
            }
            else
            {
                nCurKneadWidth = KNEAD_WIDTH_UNKNOWN_2 ;
                nFinalKneadMotorState = STATE_RUN_CLOCK ;
            }
            break ;
        case KNEAD_RUN_STOP_AT_MAX_2:
            if(bHasKneadWidthMaxPulse == TRUE)
            {
                bHasKneadWidthMaxPulse = FALSE ;
                nCurKneadMotorCycles++ ;
                if(nCurKneadMotorCycles > nKneadMotorCycles)
                {
                   // if(Input_GetKneadMax() == 0)
                    {
                        nCurKneadWidth = KNEAD_WIDTH_MAX_2 ;
                        nFinalKneadMotorState = STATE_IDLE ;
                        bKneadMotorInProcess = FALSE ;
                    }
                }
            }
            else
            {
                nCurKneadWidth = KNEAD_WIDTH_UNKNOWN_2 ;
                nFinalKneadMotorState = STATE_RUN_CLOCK ;
            }
            break ;


        }
    }
    //确定揉捏马达的速度
    if((nKneadMotorState == KNEAD_STOP_AT_MIN_2) ||
       (nKneadMotorState == KNEAD_STOP_AT_MED_2) ||
           (nKneadMotorState == KNEAD_STOP_AT_MAX_2) ||
               (nKneadMotorState == KNEAD_RUN_STOP_2) )
    {
        speed =  KNEAD_SPEED2_PWM;
    }
    else
    {
        switch(nCurKneadKnockSpeed)
        {
        default:  
        case 1:speed = KNEAD_SPEED1_PWM;  break ;
        case 2:speed = KNEAD_SPEED2_PWM;  break ;
        case 3:speed = KNEAD_SPEED3_PWM;  break ;
        case 4:speed = KNEAD_SPEED4_PWM;  break ;
        case 5:speed = KNEAD_SPEED5_PWM;  break ;
        case 6:speed = KNEAD_SPEED6_PWM;  break ;
        }
    }
    if(nFinalKneadMotorState == STATE_RUN_CLOCK)
    {
        KneadMotor_Control(STATE_KNEAD_CLOCK_RUN,speed);
    }
    if(nFinalKneadMotorState == STATE_RUN_UNCLOCK)
    {
        KneadMotor_Control(STATE_KNEAD_UNCLOCK_RUN,speed);
    }
    if(nFinalKneadMotorState == STATE_IDLE)
    {
        KneadMotor_Control(STATE_KNEAD_IDLE,speed);
    }
#endif
}

#ifndef addr_1

unsigned char WalkMotorControl_2(unsigned char nWalkMotorLocateMethod,unsigned short nWalkMotorLocateParam)
{
    //坐标更新，只有在更换动作时才执行一次
    unsigned short by_TopPosition = TOP_POSITION;
    static unsigned short nFinalWalkMotorLocate = TOP_POSITION; //add by syx 20160424


    
    if(Input_GetWalkUpSwitch() == REACH_WALK_LIMIT)
    {
      Input_SetWalkMotorPosition(TOP_POSITION);//4
    }
    if(Input_GetWalkDownSwitch() == REACH_WALK_LIMIT)
    {
       // Input_SetWalkMotorPosition(0);
    }
    
 
    if(bUpdateLocate == TRUE)
    {
        bUpdateLocate = FALSE ;
        //nWalkMotorLocateState = nWalkMotorLocateMethod;
        switch(nWalkMotorLocateMethod)
        {
        default:  
            bWalkMotorInProcess = FALSE ;
            break;
        case WALK_SHOULDER_WAIST_1_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10);
            //printf("S:%d\n\r",nShoulderPosition);
            //printf("1_10:%d\n\r",nFinalWalkMotorLocate);
            break ;
        case WALK_SHOULDER_WAIST_2_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10*2);
            //printf("2_10:%d\n\r",nFinalWalkMotorLocate);
            break ;     
        case WALK_SHOULDER_WAIST_3_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10*3);
            //printf("3_10:%d\n\r",nFinalWalkMotorLocate);
            break ;          
        case WALK_SHOULDER_WAIST_4_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10*4);
            //printf("4_10:%d\n\r",nFinalWalkMotorLocate);
            break ;               
        case WALK_SHOULDER_WAIST_5_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10*5);
            //printf("5_10:%d\n\r",nFinalWalkMotorLocate);
            break ;                    
        case WALK_SHOULDER_WAIST_6_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10*6);
            //printf("6_10:%d\n\r",nFinalWalkMotorLocate);
            break ;                       
        case WALK_SHOULDER_WAIST_7_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10*7);
            //printf("7_10:%d\n\r",nFinalWalkMotorLocate);
            break ;                       
        case WALK_SHOULDER_WAIST_8_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10*8);
            //printf("8_10:%d\n\r",nFinalWalkMotorLocate);
            break ;                       
        case WALK_SHOULDER_WAIST_9_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10*9);
            //printf("9_10:%d\n\r",nFinalWalkMotorLocate);
            break ;                       
        case WALK_LOCATE_WAIST:
            nFinalWalkMotorLocate = WAIST_POSITION ; 
            //printf("W:%d\n\r",nFinalWalkMotorLocate);
            break ;
        case WALK_LOCATE_ABSULATE:    //运行到绝对位置
            nFinalWalkMotorLocate = nWalkMotorLocateParam ; 
	   if(nFinalWalkMotorLocate > by_TopPosition)
            {
                nFinalWalkMotorLocate = by_TopPosition ;
            }
            break ;
        case WALK_LOCATE_SHOULDER:    //运行到肩膀位置
            nFinalWalkMotorLocate =  nShoulderPosition -nWalkMotorLocateParam-10;
						if(nFinalWalkMotorLocate > by_TopPosition)
            {
                nFinalWalkMotorLocate = by_TopPosition ;
            }

						
						
						
						
            break ;
        case WALK_LOCATE_TOP:  //运行到上端行程
//#ifdef TOP_BY_LIMIT
            nFinalWalkMotorLocate = by_TopPosition ;
						/*
#else
            if(nBackMainRunMode == BACK_MAIN_MODE_AUTO)
            {
                if(nShoulderPosition >= by_TopPosition - DEFAULT_NECK_LENGTH)
                {
                    nFinalWalkMotorLocate = by_TopPosition ;
                }
                else
                {
                    nFinalWalkMotorLocate = nShoulderPosition + DEFAULT_NECK_LENGTH ;
                }
            }
            else
            {
                nFinalWalkMotorLocate = by_TopPosition ;
            }
#endif
*/
            break ;
        case WALK_LOCATE_SHOULDER_OR_ABSULATE:  //由肩部位置和绝对坐标中的较小者决定
            if(nWalkMotorLocateParam > nShoulderPosition)
            {
                nFinalWalkMotorLocate = nShoulderPosition ;
            }
            else
            {
                nFinalWalkMotorLocate = nWalkMotorLocateParam ;
            }
            break ;
        case WALK_LOCATE_PARK: //停留在当前位置
            WalkMotor_Control_2(STATE_WALK_IDLE,0);
            nCurActionStepCounter = 0 ;
            break ;
            /*     
        case WALK_LOCATE_NeckSwitch:
            nFinalWalkMotorLocate = by_TopPosition ;
            break;
            */   
        case WALK_LOCATE_NeckMed: //脖子中间位置
            if(nShoulderPosition >= by_TopPosition - Med_NECK_LENGTH)
            {
                nFinalWalkMotorLocate = by_TopPosition ;
            }
            else
            {
                nFinalWalkMotorLocate = nShoulderPosition + Med_NECK_LENGTH ;
            }
            
            break;
        case WALK_LOCATE_PressNeck: //脖子位置,靠近肩膀
            nFinalWalkMotorLocate = nShoulderPosition;	//10 ;
            break;
        }//end switch
        //保证不超过最高位
        if(nFinalWalkMotorLocate > by_TopPosition)
            nFinalWalkMotorLocate = by_TopPosition;   
    }//end if
    
    //以下判断 walk 行程（bWalkMotorInProcess）何时停止 
    
    if(nWalkMotorLocateMethod == WALK_LOCATE_PARK)
    { //判断是否到达停留时间
        WalkMotor_Control_2(STATE_WALK_IDLE,0);
        if((nWalkMotorLocateParam != MAX_PARK_TIME) && 
           (nCurActionStepCounter >= nWalkMotorLocateParam))
        {
            bWalkMotorInProcess = FALSE ;
						bWalkMotorInProcess = FALSE ;
						bWalkMotorInProcess = FALSE ;
						bWalkMotorInProcess = FALSE ;
        }
    }
    else
    {
        if(nFinalWalkMotorLocate == 0)  //行程最终位置为0
        {
            if(WalkMotor_Control_2(STATE_RUN_WALK_DOWN,0))
            {
               bWalkMotorInProcess = FALSE ;
                bWalkMotorInProcess = FALSE ;
            }
            if(WalkMotor_Control_2(STATE_RUN_WALK_POSITION,0))
            {
                bWalkMotorInProcess = FALSE ;
                bWalkMotorInProcess = FALSE ;
            }   
            
        }
        else if(nFinalWalkMotorLocate >= by_TopPosition) //行程最终位置为最高
        {
            if(WalkMotor_Control(STATE_RUN_WALK_UP,0))
            {
                bWalkMotorInProcess = FALSE ;
            }
        }
        else
        {   //行程最终位置为任意位置
            if(WalkMotor_Control(STATE_RUN_WALK_POSITION,nFinalWalkMotorLocate))
            {
                bWalkMotorInProcess = FALSE ;
            }
        }
    }
    return 0;
}

#endif

#ifdef addr_1
unsigned char WalkMotorControl(unsigned char nWalkMotorLocateMethod,unsigned short nWalkMotorLocateParam)
{
    //坐标更新，只有在更换动作时才执行一次
  //上行程最高点会动态调整
  //下面机芯没有肩位检测功能
    unsigned short by_TopPosition= 0xffff;///nWalk_TOP_POSITION;//TOP_POSITION;
    static unsigned short nFinalWalkMotorLocate =0;//nWalk_TOP_POSITION;//TOP_POSITION; //add by syx 20160424

 //   bUpdateLocate=1;
    
  // nWalkMotorLocateMethod=WALK_LOCATE_TOP;//WALK_LOCATE_ABSULATE;//WALK_LOCATE_ABSULATE;
    
  // nWalkMotorLocateMethod=WALK_LOCATE_ABSULATE;//WALK_LOCATE_ABSULATE;
  //  nWalkMotorLocateParam=0;//100;//100;
    
    if(Input_GetWalkUpSwitch() == REACH_WALK_LIMIT)
    {
        if(bCheckWalkBottom)//获取当前最新的最高点坐标
        {
        nWalk_TOP_POSITION=Input_GetWalkMotorPosition();
        Input_SetWalkMotorPosition(nWalk_TOP_POSITION);//4
        }
    }
    if(Input_GetWalkDownSwitch() == REACH_WALK_LIMIT)
    {
        Input_SetWalkMotorPosition(0);
    }
    
 
    if(bUpdateLocate == TRUE)
    {
        bUpdateLocate = FALSE ;
        //nWalkMotorLocateState = nWalkMotorLocateMethod;
        switch(nWalkMotorLocateMethod)
        {
        default:  
            bWalkMotorInProcess = FALSE ;
            break;
      /*  case WALK_SHOULDER_WAIST_1_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10);
            //printf("S:%d\n\r",nShoulderPosition);
            //printf("1_10:%d\n\r",nFinalWalkMotorLocate);
            break ;
        case WALK_SHOULDER_WAIST_2_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10*2);
            //printf("2_10:%d\n\r",nFinalWalkMotorLocate);
            break ;     
        case WALK_SHOULDER_WAIST_3_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10*3);
            //printf("3_10:%d\n\r",nFinalWalkMotorLocate);
            break ;          
        case WALK_SHOULDER_WAIST_4_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10*4);
            //printf("4_10:%d\n\r",nFinalWalkMotorLocate);
            break ;               
        case WALK_SHOULDER_WAIST_5_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10*5);
            //printf("5_10:%d\n\r",nFinalWalkMotorLocate);
            break ;                    
        case WALK_SHOULDER_WAIST_6_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10*6);
            //printf("6_10:%d\n\r",nFinalWalkMotorLocate);
            break ;                       
        case WALK_SHOULDER_WAIST_7_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10*7);
            //printf("7_10:%d\n\r",nFinalWalkMotorLocate);
            break ;                       
        case WALK_SHOULDER_WAIST_8_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10*8);
            //printf("8_10:%d\n\r",nFinalWalkMotorLocate);
            break ;                       
        case WALK_SHOULDER_WAIST_9_10:
            nFinalWalkMotorLocate = nShoulderPosition - ((nShoulderPosition - WAIST_POSITION)/10*9);
            //printf("9_10:%d\n\r",nFinalWalkMotorLocate);
            break ;        */               
        case WALK_LOCATE_WAIST:
            nFinalWalkMotorLocate = WAIST_POSITION ; 
            //printf("W:%d\n\r",nFinalWalkMotorLocate);
            break ;
        case WALK_LOCATE_ABSULATE:    //运行到绝对位置
            nFinalWalkMotorLocate = nWalkMotorLocateParam ; 
	  /* if(nFinalWalkMotorLocate >nWalk_TOP_POSITION)// by_TopPosition)
            {
                nFinalWalkMotorLocate =nWalk_TOP_POSITION;// by_TopPosition ;
            }*/
            break ;
      /*  case WALK_LOCATE_SHOULDER:    //运行到肩膀位置
            nFinalWalkMotorLocate =  nShoulderPosition -nWalkMotorLocateParam-10;
	    if(nFinalWalkMotorLocate > by_TopPosition)
            {
                nFinalWalkMotorLocate = by_TopPosition ;
            }

						
						
						
						
            break ;*/
        case WALK_LOCATE_TOP:  //运行到上端行程

            nFinalWalkMotorLocate = by_TopPosition ;

            break ;
      /*  case WALK_LOCATE_SHOULDER_OR_ABSULATE:  //由肩部位置和绝对坐标中的较小者决定
            if(nWalkMotorLocateParam > nShoulderPosition)
            {
                nFinalWalkMotorLocate = nShoulderPosition ;
            }
            else
            {
                nFinalWalkMotorLocate = nWalkMotorLocateParam ;
            }
            break ;*/
        case WALK_LOCATE_PARK: //停留在当前位置
            WalkMotor_Control(STATE_WALK_IDLE,0);
            nCurActionStepCounter = 0 ;
            break ;

      /*  case WALK_LOCATE_NeckMed: //脖子中间位置
            if(nShoulderPosition >= by_TopPosition - Med_NECK_LENGTH)
            {
                nFinalWalkMotorLocate = by_TopPosition ;
            }
            else
            {
                nFinalWalkMotorLocate = nShoulderPosition + Med_NECK_LENGTH ;
            }
            
            break;
        case WALK_LOCATE_PressNeck: //脖子位置,靠近肩膀
            nFinalWalkMotorLocate = nShoulderPosition;	//10 ;
            break;*/
        }//end switch
        //保证不超过最高位
        if(nFinalWalkMotorLocate >= by_TopPosition)
            nFinalWalkMotorLocate = by_TopPosition;   
    }//end if
    
    //以下判断 walk 行程（bWalkMotorInProcess）何时停止 
    
    if(nWalkMotorLocateMethod == WALK_LOCATE_PARK)
    { //判断是否到达停留时间
        WalkMotor_Control(STATE_WALK_IDLE,0);
        if((nWalkMotorLocateParam != MAX_PARK_TIME) && 
           (nCurActionStepCounter >= nWalkMotorLocateParam))
        {
            bWalkMotorInProcess = FALSE ;

        }
    }
    else
    {
        if(nFinalWalkMotorLocate == 0)  //行程最终位置为0
        {
            if(WalkMotor_Control(STATE_RUN_WALK_DOWN,0))
            {
                bWalkMotorInProcess = FALSE ;
            }
        }
        else if(nFinalWalkMotorLocate >= by_TopPosition) //行程最终位置为最高
        {
            if(WalkMotor_Control(STATE_RUN_WALK_UP,0))
            {
                bWalkMotorInProcess = FALSE ;
            }
        }
        else
        {   //行程最终位置为任意位置
            if(WalkMotor_Control(STATE_RUN_WALK_POSITION,nFinalWalkMotorLocate))
            {
                bWalkMotorInProcess = FALSE ;
            }
        }
    }
    return 0;
}
#endif

//----------------------------------------------------------------

